input {
  # Log de consultas de MySQL
  file {
    path => "/var/log/mysql/mysql.log"  # Ruta del log de consultas de MySQL
    start_position => "beginning"
    sincedb_path => "/dev/null"
    stat_interval => 2
    codec => "plain"
  }

  # Log de errores de MySQL
  file {
    path => "/var/log/mysql/error.log"  # Ruta del log de errores de MySQL
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "plain"
  }
}

filter {
  # Filtro para las consultas de MySQL
  if [path] =~ "mysql.log" {
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:log_level}\] %{GREEDYDATA:log_message}"
      }
    }

    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }

  # Filtro para los errores de MySQL
  if [path] =~ "error.log" {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:log_level}\] %{GREEDYDATA:error_message}"
      }
    }

    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }
}

output {
  # Enviar los logs de consultas a Elasticsearch
  if [path] =~ "mysql.log" {
    elasticsearch {
      hosts => ["https://172.26.203.193:9200"]
      user => "elastic"
      password => "Ivancasillas36"
      ssl => true
      ssl_certificate_verification => false
      index => "mysql-logs-%{+YYYY.MM.dd}"
    }
  }

  # Enviar los logs de errores a Elasticsearch
  if [path] =~ "error.log" {
    elasticsearch {
      hosts => ["https://172.26.203.193:9200"]
      user => "elastic"
      password => "Ivancasillas36"
      ssl => true
      ssl_certificate_verification => false
      index => "mysql-error-logs-%{+YYYY.MM.dd}"
    }
  }

  # Output de depuraciÃ³n (solo para probar)
  stdout {
    codec => rubydebug
  }
}

